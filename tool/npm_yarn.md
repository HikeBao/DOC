#### 版本号

```javascript
{
    'dependencies': {
        'asd': 'http://asdf.com/asdf.tar.gz',   //在版本上指定一个压缩包的url，当执行npm install 时这个压缩包会被下载并安装到本地。
        'lat': 'latest',             //安装最新版本
        'dyl': 'file:../dyl',         //使用本地路径
        'adf': 'git://github.com/user/project.git#commit-ish' //使用git URL加commit-ish
        }
};

版本号的优先级范例：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。
```



#### 为什么要使用语义化的版本控制？

```go
这并不是一个新的或者革命性的想法。实际上，你可能已经在做一些近似的事情了。问题在于只是“近似”还不够。如果没有某个正式的规范可循，版本号对于依赖的管理并无实质意义。将上述的想法命名并给予清楚的定义，让你对软件使用者传达意向变得容易。一旦这些意向变得清楚，弹性（但又不会太弹性）的依赖规范就能达成。

举个简单的例子就可以展示语义化的版本控制如何让依赖地狱成为过去。假设有个名为“救火车”的函式库，它需要另一个名为“梯子”并已经有使用语义化版本控制的包。当救火车创建时，梯子的版本号为 3.1.0。因为救火车使用了一些版本 3.1.0 所新增的功能， 你可以放心地指定依赖于梯子的版本号大等于 3.1.0 但小于 4.0.0。这样，当梯子版本 3.1.1 和 3.2.0 发布时，你可以将直接它们纳入你的包管理系统，因为它们能与原有依赖的软件兼容。

作为一位负责任的开发者，你理当确保每次包升级的运作与版本号的表述一致。现实世界是复杂的，我们除了提高警觉外能做的不多。你所能做的就是让语义化的版本控制为你提供一个健全的方式来发行以及升级包，而无需推出新的依赖包，节省你的时间及烦恼。

如果你对此认同，希望立即开始使用语义化版本控制，你只需声明你的函式库正在使用它并遵循这些规则就可以了。请在你的 README 文件中保留此页连结，让别人也知道这些规则并从中受益。
```



#### 常用指令

```javascript
`npm i packageName -D`: --save-dev 写入devDependencies
`npm i packageName -S`:  --save    写入dependencies
`npm i packageName -g`:  --global 全局安装  注意，一定不能使用-G

`npm view packageName versions`:查看当前包的版本信息，有s则代表所有版本，没s代表现在本地的版本
`packName --version`：查看包的本地版本
`yarn add packName@latest`: 安装最新的包
`yarn cache clean`: 清除缓存

# 设置镜像
yarn/npm config set registry https://registry.npm.taobao.org
yarn/npm config get registry
```





#### 如何发布包

```javascript
- 在镜像源那注册一个账号
- 然后在项目中(package.json)目录下进行npm login
- 最后使用npm publish  -- 谨记不要加包名
- 注意package.json中的name必须是唯一的，不然会发布不成功

# 如何创建一个npm镜像
- npm config set registry URL
```



#### yarn link失败原因

```javascript
# 首先是设置环境变量
# 然后就是yarn global add packageName
# 再次是在yarn的启动目录下面的global文件yarn link
# 最后在项目里面使用yarn link对应的包


`yarn || npm`： 之前在项目中踩过一个坑，就是无法下载最新改动的包，后来发现是由于`yarn`缓存造成的，所以，下次遇到下载不到最新包，可以使用`yarn cache clean`
npm link 意思是将当前的模块link到全局，而npm link packName 则是将当前全局的包link到本项目中去，所以使用npm link、npm link PackageName 必须在package.json目录下
```



#### yarn特点

- 安装缓存，支持离线安装，当然npm也有对应的离线缓存方案。
- workspace公共区，优化项目依赖。2.0推出并发打包命令`yarn workspaces foreach -pt run build`
- 像webpack一样，通过插件给yarn赋能



## FAQ

### 在 0.y.z 初始开发阶段，我该如何进行版本控制？

最简单的做法是以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号。

### 如何判断发布 1.0.0 版本的时机？

当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。如果你已经有个稳定的 API 被使用者依赖，也会是 1.0.0 版。如果你很担心向下兼容的问题，也应该算是 1.0.0 版了。

### 这不会阻碍快速开发和迭代吗？

主版本号为零的时候就是为了做快速开发。如果你每天都在改变 API，那么你应该仍在主版本号为零的阶段（0.y.z），或是正在下个主版本的独立开发分支中。

### 对于公共 API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到 42.0.0 版？

这是开发的责任感和前瞻性的问题。不兼容的改变不应该轻易被加入到有许多依赖代码的软件中。升级所付出的代价可能是巨大的。要递增主版本号来发行不兼容的改版，意味着你必须为这些改变所带来的影响深思熟虑，并且评估所涉及的成本及效益比。

### 为整个公共 API 写文件太费事了！

为供他人使用的软件编写适当的文件，是你作为一名专业开发者应尽的职责。保持专案高效一个非常重要的部份是掌控软件的复杂度，如果没有人知道如何使用你的软件或不知道哪些函数的调用是可靠的，要掌控复杂度会是困难的。长远来看，使用语义化版本控制以及对于公共 API 有良好规范的坚持，可以让每个人及每件事都运行顺畅。

### 万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？

一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并发行一个新的次版本号来更正这个问题并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。可以的话，将有问题的版本号记录到文件中，告诉使用者问题所在，让他们能够意识到这是有问题的版本。

### 如果我更新了自己的依赖但没有改变公共 API 该怎么办？

由于没有影响到公共 API，这可以被认定是兼容的。若某个软件和你的包有共同依赖，则它会有自己的依赖规范，作者也会告知可能的冲突。要判断改版是属于修订等级或是次版等级，是依据你更新的依赖关系是为了修复问题或是加入新功能。对于后者，我经常会预期伴随着更多的代码，这显然会是一个次版本号级别的递增。

### 如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）

自行做最佳的判断。如果你有庞大的使用者群在依照公共 API 的意图而变更行为后会大受影响，那么最好做一次主版本的发布，即使严格来说这个修复仅是修订等级的发布。记住， 语义化的版本控制就是透过版本号的改变来传达意义。若这些改变对你的使用者是重要的，那就透过版本号来向他们说明。

### 我该如何处理即将弃用的功能？

弃用现存的功能是软件开发中的家常便饭，也通常是向前发展所必须的。当你弃用部份公共 API 时，你应该做两件事：（1）更新你的文件让使用者知道这个改变，（2）在适当的时机将弃用的功能透过新的次版本号发布。在新的主版本完全移除弃用功能前，至少要有一个次版本包含这个弃用信息，这样使用者才能平顺地转移到新版 API。

### 语义化版本对于版本的字串长度是否有限制呢？

没有，请自行做适当的判断。举例来说，长到 255 个字元的版本已过度夸张。再者，特定的系统对于字串长度可能会有他们自己的限制。

